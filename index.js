'use strict';const fs=require("fs"),path=require("path"),{EventEmitter}=require("events");class Database extends EventEmitter{constructor(a="database.json",b={}){if(super(),"string"!=typeof a)throw new TypeError("Location must be a string");if("an object"!==typeOf(b))throw new TypeError("Options must be an object");if(b=Object.assign({spaces:2,force:!1},b),"number"!=typeof b.spaces)throw new TypeError("Spaces option must be a number");if("boolean"!=typeof b.force)throw new TypeError("Force option must be boolean");(!a||a.endsWith("/"))&&(a+="database.json"),b.force||a.split("/").pop().includes(".")||(a+=".json");let c=a.replace(/\.(\.)?\//g,"").split(".");if(!b.force&&1!==c.length&&!["json","sql"].includes(c[c.length-1]))throw new Error(`File extension '${c[c.length-1]}' is not supported, Please use the 'json' or 'sql' file extension`);let d=a.split("/");c=d.pop(),d=d.join("/");let e=`${path.resolve(d)}/${c}`;fs.existsSync(d||"./")||fs.mkdirSync(d,{recursive:!0}),fs.existsSync(e)||(fs.closeSync(fs.openSync(e,"w")),fs.writeFileSync(e,"{}")),Object.defineProperties(this,{filePath:{value:e,enumerable:!0,writable:!0},spaces:{value:Math.min(Math.max(b.spaces,0),4),writable:!0},force:{value:b.force}}),fs.writeFileSync(this.filePath,JSON.stringify(this.read(),null,this.spaces)),this.history=[this.read()],this.on("change",(a,b,c)=>this.history.unshift(c))}setSpaces(a=2){if(a=+a,isNaN(a))throw new TypeError("Spaces cannot be "+typeOf(a));return a=Math.min(Math.max(a,0),4),this.spaces=a,fs.writeFileSync(this.filePath,JSON.stringify(this.read(),null,a)),this}toString(){return fs.readFileSync(this.filePath,"utf8")}add(a,b=1){if(0===arguments.length)throw new Error("Missing JSON path");if("string"!=typeof a)throw new TypeError("Path must be a string");if("number"!=typeof b)throw new TypeError("Amount must be a number");if(isNaN(b))throw new TypeError(`Amount connot be ${typeOf(b)}`);let c=this.get(a);if("number"!=typeof c)throw new TypeError(`Path must lead to a number. Received: ${typeOf(c)}`);return c+=b,this.set(a,c)}sub(a,b=1){if(0===arguments.length)throw new Error("Missing JSON path");if("string"!=typeof a)throw new TypeError("Path must be a string");if("number"!=typeof b)throw new TypeError("Amount must be a number");if(isNaN(b))throw new TypeError(`Amount connot be ${typeOf(b)}`);let c=this.get(a);if("number"!=typeof c)throw new TypeError(`Path must lead to a number. Received: ${typeOf(c)}`);return c-=b,this.set(a,c)}get(a=""){if("string"!=typeof a)throw new TypeError("Path must be a string");return a?_get(a,this.read()):this.read()}set(a,b){if(0===arguments.length)throw new Error("Missing JSON path");if(""===a){if("an object"!==typeOf(b)&&"an array"!==typeOf(b))throw new TypeError(`Cannot set JSON to ${typeOf(b)}`);return this.toString()!==JSON.stringify(b,null,this.spaces)&&(this.emit("change",a,this.read(),JSON.parse(JSON.stringify(b))),fs.writeFileSync(this.filePath,JSON.stringify(b,null,this.spaces))),this}if("string"!=typeof a)throw new TypeError("Path must be a string");if("{}"===JSON.stringify({value:b}))throw new TypeError(`Value cannot be ${"number"==typeof b?b:typeOf(b)}`);let c=this.get(a);if(c!==b){if(("an object"===typeOf(c)||"an array"===typeOf(c))&&("an object"===typeOf(b)||"an array"===typeOf(b))&&JSON.stringify(c)===JSON.stringify(b))return this;let d=this.read();if(d=_set(a,b,d),JSON.stringify(this.read())===JSON.stringify(d))return this;this.emit("change",a,this.read(),JSON.parse(JSON.stringify(d))),fs.writeFileSync(this.filePath,JSON.stringify(d,null,this.spaces))}return this}delete(a){if(0===arguments.length)throw new Error("Missing JSON path");if("string"!=typeof a)throw new TypeError("Path must be a string");if(!this.has(a))return this;let b=this.read();return b=_delete(a,b),this.emit("change",a,this.read(),JSON.parse(JSON.stringify(b))),fs.writeFileSync(this.filePath,JSON.stringify(b,null,this.spaces)),this}find(a,b){if(0===arguments.length)throw new Error("Missing JSON path");if("string"!=typeof a)throw new TypeError("Path must be a string");let c=this.get(a);if("an object"!==typeOf(c))throw new TypeError("Path must lead to an object");if("function"!=typeof b)throw new TypeError("fn must be a function");for(const[d,e]of Object.entries(c))if(b(e,d))return e}findAll(a,b){if(0===arguments.length)throw new Error("Missing JSON path");if("string"!=typeof a)throw new TypeError("Path must be a string");let c=this.get(a);if("an object"!==typeOf(c))throw new TypeError("Path must lead to an object");if("function"!=typeof b)throw new TypeError("fn must be a function");let d=[];for(const[e,f]of Object.entries(c))b(f,e)&&(d[d.length]=f);if(0!==d.length)return d}has(a){if(0===arguments.length)throw new Error("Missing JSON path");if("string"!=typeof a)throw new TypeError("Path must be a string");return this.get(a)!==void 0}read(){return JSON.parse(fs.readFileSync(this.filePath,"utf8"))}clear(){"{}"!==this.toString()&&this.set("",{})}moveTo(a,b=!0){if(0===arguments.length)throw new Error("No location provided");if("string"!=typeof a)throw new TypeError("Location must be a string");if("boolean"!=typeof b)throw new TypeError("DeleteFile must be boolean");const c=new Database(a,{spaces:this.spaces,force:this.force});return fs.writeFileSync(c.filePath,JSON.stringify(this.read(),null,this.spaces)),b&&fs.unlinkSync(this.filePath),c.history=this.history,Object.assign(this,c),this}entries(){return Object.entries(this.read())}clone(){const a=new Database(this.filePath,{spaces:this.spaces,force:this.force});return a.history=this.history,a}}function typeOf(a){return("object"==typeof a?null===a?"":"an ":a===void 0||"boolean"==typeof a?"":"a ")+(null===a?a:a instanceof Array?"array":typeof a)}function _delete(a,b){let c=a.split("."),d=b;for(let e=0;e<c.length-1;e++)d=d[c[e]];return delete d[c[c.length-1]],b}function _set(a,b,c){let d=a.split("."),e=c;for(let f=0;f<d.length-1;f++)e=void 0===e[d[f]]?e[d[f]]={}:e[d[f]];return e[d[d.length-1]]=b,c}function _get(a,b){let c=a.split(".");for(let d=0;d<c.length;d++)if(b=b[c[d]],void 0===b)return;return b}Database.Database=Database,module.exports=Database;